
#ifndef _METRIC_MAPPING_REDIF_HPP
#define _METRIC_MAPPING_REDIF_HPP

#include "modules/distance/k-related/Standards.hpp"
#include <blaze/Blaze.h>

#include <vector>

namespace metric {
/**
 * @class Kohonen
 *
 * @brief
 *
 * Encode dataset based on an inverse Diffusion Process.
 * By training a model based on an inverse (or backward) Diffusion
 * Process, noisy records can be denoised (encoded) and decoded.
 *
 * The noisy training data is denoised by solving a backward diffusion
 * process with the help of graph Laplacian of a random neighborhood graph
 * generated by the samples.
 *
 */
template <typename Tv = double, class Metric = metric::Euclidean<Tv>> class Redif {
  public:
	/**
	 * @brief
	 * Constructor for Redif
	 *
	 * @param trainData - Data Set for training the Denoising Model
	 * @param nNeighbors - The number of nearest neighbors considered in building the distance matrix. (Default: 10)
	 * @param nIter - Number of iterations (default: 15)
	 * @param metric - Metric used for train and evaluation.
	 */
	Redif(const std::vector<std::vector<Tv>> &trainData, size_t nNeighbors = 10, size_t nIter = 15,
		  Metric metric = Metric());
	~Redif() = default;

	/**
	 * @brief
	 * Encodes (denoises) record based on pretrained Diffusion model.
	 * Based on a training set and the Laplacian Matrices of all iterations of
	 * the backward Diffusion process records `x` dataset are being denoised.
	 *
	 * @param x - 'Noisy' Records.
	 *
	 * @return denoised (encoded) records.
	 */
	std::vector<std::vector<Tv>> encode(const std::vector<std::vector<Tv>> &x);

	/**
	 * @brief
	 * Decodes denoised (encoded) data based on the pretrained denoising Diffusion model.
	 * Based on a denoised training set and the Laplacian Matrices of all
	 * iterations of the reverse diffusion process, the process is reveresed back.
	 *
	 * @param xEncoded - Denoised (encoded) records.
	 *
	 * @return Decoded records.
	 */
	std::vector<std::vector<Tv>> decode(const std::vector<std::vector<Tv>> &xEncoded);

	/**
	 * @brief
	 * Accesses property xTrainEncoded.
	 */
	std::vector<std::vector<Tv>> get_train_encoded()
	{
		std::vector<std::vector<Tv>> encoded_data_as_vectors(xTrainEncoded.rows(),
															 std::vector<Tv>(xTrainEncoded.columns()));
		for (size_t i = 0; i < xTrainEncoded.rows(); i++)
			for (size_t j = 0; j < xTrainEncoded.columns(); j++)
				encoded_data_as_vectors[i][j] = xTrainEncoded(i, j);

		return encoded_data_as_vectors;
	}

  private:
	/**
	 * @brief
	 *
	 * @param idx
	 * @param data
	 * @param start
	 * @param end
	 */
	template <bool flag = blaze::rowVector>
	void Quicksort(blaze::DynamicVector<size_t> &idx, blaze::DynamicVector<Tv, flag> &data, size_t start, size_t end);

	template <bool flag = blaze::rowVector>
	size_t partition(blaze::DynamicVector<size_t> &idx, blaze::DynamicVector<Tv, flag> &data, size_t start, size_t end);

	/**
	 * @brief
	 * Encodes (denoises) record based on pretrained Diffusion model.
	 * Based on a training set and the Laplacian Matrices of all iterations of
	 * the backward Diffusion process records `x` dataset are being denoised.
	 *
	 * @param x - 'Noisy' Records
	 *
	 * @return denoised (encoded) records.
	 */
	blaze::DynamicMatrix<Tv> encode(const blaze::DynamicMatrix<Tv> &x);

	/**
	 * @brief
	 * Decodes denoised (encoded) data based on the pretrained denoising Diffusion model.
	 * Based on a denoised training set and the Laplacian Matrices of all
	 * iterations of the reverse diffusion process, the process is reveresed back.
	 *
	 * @param xEncoded - Denoised (encoded) records.
	 *
	 * @return Decoded records.
	 */
	blaze::DynamicMatrix<Tv> decode(const blaze::DynamicMatrix<Tv> &xEncoded);

	/**
	 * @brief
	 * Calculates local Distance Matrix based on `nNeighbors` and `metric`.
	 *
	 * @param dataSample - Data samples.
	 *
	 * @return Local Distance Matrix
	 */
	blaze::DynamicMatrix<Tv> getLocalDistMatrix(const blaze::DynamicMatrix<Tv> &dataSample);

	/**
	 * @brief
	 * Calculates the weighted Graph Laplacian.
	 *
	 * @param localDist - Local Distance Matrix
	 *
	 * @return Weighted Graph Laplacian.
	 */
	blaze::DynamicMatrix<Tv> calcWeightedGraphLaplacian(const blaze::DynamicMatrix<Tv> &localDist);

	/**
	 * @brief
	 * Builds the Diffusion Model based on train dataset.
	 *
	 * The noisy training data is denoised by solving a backward diffusion
	 * process with the help of graph Laplacian of a random neighborhood graph
	 * generated by the samples. The Laplacian Matrices are saved for each iteration.
	 *
	 * @param nIter - Number of iterations (default: 15)
	 *
	 * @return Denoised data (encoded train dataset).
	 */
	blaze::DynamicMatrix<Tv> trainModel(size_t nIter);

	/**
	 * @brief
	 * The number of nearest neighbors considered in building the distance matrix.
	 */
	size_t nNeighbors;

	/**
	 * @brief
	 * Metric used for train and evaluation.
	 */
	Metric metric;

	/**
	 * @brief
	 * Data Set for training the Denoising Model (original dataset).
	 */
	blaze::DynamicMatrix<Tv> xTrain;

	/**
	 * @brief
	 * Encoded train dataset.
	 */
	blaze::DynamicMatrix<Tv> xTrainEncoded;

	/**
	 * @brief
	 * Diffusion Model. Laplacian Matrices of each iteration.
	 */
	std::vector<blaze::DynamicMatrix<Tv>> LArray;
};

} // namespace metric

#include "Redif.cpp"

#endif // Header Guard
