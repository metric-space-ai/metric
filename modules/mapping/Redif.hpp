#pragma once

#include "../../3rdparty/blaze/Blaze.h"
#include "../../modules/distance.hpp"

#include <vector>

namespace metric
{
	/**
 * @class Kohonen
 *
 * @brief 
 * 
 * Encode dataset based on an inverse Diffusion Process.
 * By training a model based on an inverse (or backward) Diffusion 
 * Process, noisy records can be denoised (encoded) and decoded.
 * 
 * The noisy training data is denoised by solving a backward diffusion 
 * process with the help of graph Laplacian of a random neighborhood graph 
 * generated by the samples. 
 *
 */
template<typename Tv = double, class Metric = metric::Euclidean<Tv>>
class Redif
{
public:
	
    /**
     * @brief 
     * Constructor for Redif
     *
     * @param trainData - Data Set for training the Denoising Model
	 * @param nNeighbors - The number of nearest neighbors considered in building the distance matrix. (Default: 10)
     * @param nIter - Number of iterations (default: 15)
     * @param metric - Metric used for train and evaluation.
     */
    Redif(
        const std::vector<std::vector<Tv>>& trainData,
        size_t nNeighbors = 10,
        size_t nIter = 15,
        Metric metric = Metric()
    );
    ~Redif() = default;
	
    /**
     * @brief
     * Encodes (denoises) record based on pretrained Diffusion model. 
	 * Based on a training set and the Laplacian Matrices of all iterations of
	 * the backward Diffusion process records `x` dataset are being denoised.
	 * 
     * @param x - 'Noisy' Records.
     *
     * @return The tuple of denoised (encoded) records and indices of nearest samples in training set to records.
     */
    std::tuple<std::vector<std::vector<Tv>>, std::vector<size_t>> encode(const std::vector<std::vector<Tv>>& x);
	
    /**
     * @brief
     * Decodes denoised (encoded) data based on the pretrained denoising Diffusion model.
	 * Based on a denoised training set and the Laplacian Matrices of all 
	 * iterations of the reverse diffusion process, the process is reveresed back.
	 * 
     * @param xEncoded - Denoised (encoded) records.
     * @param l_idx - Indices of nearest Sample in training set to records.
     *
     * @return Decoded records.
     */
    std::vector<std::vector<Tv>> decode(const std::vector<std::vector<Tv>>& xEncoded, const std::vector<size_t>& l_idx);
	
    /**
     * @brief
     * Accesses property xTrainEncoded. 
     */
	std::vector<std::vector<Tv>> get_train_encoded()
	{
		std::vector<std::vector<Tv>> encoded_data_as_vectors(xTrainEncoded.rows(), std::vector<Tv>(xTrainEncoded.columns()));	
		for (size_t i = 0; i < xTrainEncoded.rows(); i++)
			for (size_t j = 0; j < xTrainEncoded.columns(); j++)
				encoded_data_as_vectors[i][j] = xTrainEncoded(i, j);

		return encoded_data_as_vectors;
	}
private:
	
    /**
     * @brief
     *
     * @param idx
     * @param data
     * @param start
     * @param end
     */
    template<bool flag = blaze::rowVector>
    void Quicksort(blaze::DynamicVector<size_t>& idx, blaze::DynamicVector<Tv, flag>& data, size_t start, size_t end);

    template<bool flag = blaze::rowVector>
    size_t partition(
        blaze::DynamicVector<size_t> & idx,
        blaze::DynamicVector<Tv, flag> & data,
        size_t start,
        size_t end
    );
	
    /**
     * @brief
     * Encodes (denoises) record based on pretrained Diffusion model. 
	 * Based on a training set and the Laplacian Matrices of all iterations of
	 * the backward Diffusion process records `x` dataset are being denoised.
	 * 
     * @param x - 'Noisy' Records
     *
     * @return The tuple of denoised (encoded) records and indices of nearest samples in training set to records.
     */
    std::tuple<blaze::DynamicMatrix<Tv>, blaze::DynamicVector<size_t>> encode(const blaze::DynamicMatrix<Tv>& x);
	
    /**
     * @brief
     * Decodes denoised (encoded) data based on the pretrained denoising Diffusion model.
	 * Based on a denoised training set and the Laplacian Matrices of all 
	 * iterations of the reverse diffusion process, the process is reveresed back.
	 * 
     * @param xEncoded - Denoised (encoded) records.
     * @param l_idx - Indices of nearest Sample in training set to records.
     *
     * @return Decoded records.
     */
    blaze::DynamicMatrix<Tv> decode(const blaze::DynamicMatrix<Tv>& xEncoded, const blaze::DynamicVector<size_t>& l_idx);
	
    /**
     * @brief
	 * Calculates local Distance Matrix based on `nNeighbors` and `metric`.
     *
     * @param dataSample - Data samples.
     *
     * @return Local Distance Matrix
     */
    blaze::DynamicMatrix<Tv> getLocalDistMatrix(const blaze::DynamicMatrix<Tv>& dataSample);
	
    /**
     * @brief
     * Calculates the weighted Graph Laplacian.
	 * 
     * @param localDist - Local Distance Matrix
     *
     * @return Weighted Graph Laplacian.
     */
    blaze::DynamicMatrix<Tv> calcWeightedGraphLaplacian(const blaze::DynamicMatrix<Tv>& localDist);
	
    /**
     * @brief
     * Builds the Diffusion Model based on train dataset.
	 * 
	 * The noisy training data is denoised by solving a backward diffusion 
	 * process with the help of graph Laplacian of a random neighborhood graph 
	 * generated by the samples. The Laplacian Matrices are saved for each iteration.
	 * 
     * @param nIter - Number of iterations (default: 15)
     *
     * @return Denoised data (encoded train dataset).
     */
    blaze::DynamicMatrix<Tv> trainModel(size_t nIter);
	
    /**
     * @brief
     * The number of nearest neighbors considered in building the distance matrix.
     */
    size_t nNeighbors;
	
    /**
     * @brief
     * Metric used for train and evaluation.
     */
    Metric metric;
	
    /**
     * @brief
     * Data Set for training the Denoising Model (original dataset). 
     */
    blaze::DynamicMatrix<Tv> xTrain;
	
    /**
     * @brief
     * Encoded train dataset.
     */
    blaze::DynamicMatrix<Tv> xTrainEncoded;
	
    /**
     * @brief
     * Diffusion Model. Laplacian Matrices of each iteration.
     */
    std::vector<blaze::DynamicMatrix<Tv>> LArray;
};

}

#include "Redif.cpp"
